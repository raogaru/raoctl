fSplitFileToSQL () {
v_debug=0
sFile=$1
sNum=0 #SQL Count
typeset sStr=""
l_FileLineNum=0
l_SqlLineNum=1
sLineCnt=0
l_SqlTypeID=""
l_SqlType=""
l_SqlTypeUnderscore=""
l_SqlSubType=""
l_SqlObjectName=""
lStr=""
cCnt=0

DEBUG Processing $sFile

# NOTE: User TMPFILE3/4 as TMPFILE1/2 already used in DBD.sqlrule.sh

# remove multi-line comments starting with /* and ending with */  
if [ "${rc_SPLITSQL_REMOVE_CSTYLE_COMMENTS}" != "NO" ]; then
	DEBUG "Removing C-Style multi-line comments"
	cat ${sFile} | perl -p0e 's!/\*.*?\*/!!sg' > ${TMPFILE3}
else
	cp ${sFile} ${TMPFILE3}
fi

# remove multi-line comments starting with DOC and ending with #
if [ "${rc_SPLITSQL_REMOVE_DOCUMENT_COMMENTS}" != "NO" ]; then
	DEBUG "Removing DOC-# multi-line comments"
	cat ${TMPFILE3} | perl -p0e 's!DOCUMENT.*?#!!sg' | perl -p0e 's!document.*?#!!sg'> ${TMPFILE4}
else
	cp ${TMPFILE3} ${TMPFILE4}
fi

# remove empty lines
if [ "${rc_SPLITSQL_REMOVE_EMPTY_LINES}" != "NO" ]; then
	DEBUG "Removing empty lines"
	cat ${TMPFILE4} | grep -v "^$" > ${TMPFILE3}
else
	cp ${TMPFILE4}  ${TMPFILE3}
fi

# remove prompt statements
if [ "${rc_SPLITSQL_REMOVE_PROMPT_LINES}" != "NO" ]; then
	DEBUG "Removing PROMPT lines"
	cat ${TMPFILE3} |grep -iv "^[ 	]*prompt" > ${TMPFILE4}
else
	cp ${TMPFILE3}  ${TMPFILE4}
fi

# remove double hiphen comments
if [ "${rc_SPLITSQL_REMOVE_DOUBLE_HIPHEN_LINES}" != "NO" ]; then
	DEBUG "Removing DOUBLE HIPHEN comments"
	cat ${TMPFILE4} |sed -e 's/--.*$//' > ${TMPFILE3}
else
	cp ${TMPFILE4}  ${TMPFILE3}
fi

# remove leading and trailing whitespaces
if [ "${rc_SPLITSQL_REMOVE_MULTIPLE_WHITESPACES}" != "NO" ]; then
	DEBUG "Removing multiple whitespaces"
	# 1.replace tabs 2.leading spaces 3.trailing spaces 4.multiplespaces with one"
	cat ${TMPFILE3} | sed -e 's/[	]/ /g' -e 's/^[ 	]*//g' -e 's/[ 	]*$//g' -e 's/[ ][ ]*/ /g' > ${TMPFILE4}
else
	cp ${TMPFILE3}  ${TMPFILE4}
fi

#final copy in ${TMPFILE3} before processing line by line
cp ${TMPFILE4} ${TMPSCR}
rm -f ${TMPFILE3} ${TMPFILE4}

# processing begins - read full line into lStr
while read -r lStr
do
	(( l_FileLineNum=l_FileLineNum+1 ))
	(( l_SqlLineNum=l_SqlLineNum+1 ))

	# increment char count by length of line
	((cCnt=cCnt+${#lStr}))

	# first char of line
	sChar1=${lStr:0:1}

	# last char of line
	sChar2=${lStr:(-1)}

	#DEBUG "c1=$sChar1"
	#DEBUG "c2=$sChar2"

	# if first char is "/" for First line of SQL then previous sql statement is of PLSQL type 
	[[ "${sChar1}" = "/" && ${l_SqlLineNum} -eq 1 ]] && l_SqlLineNum=0 && continue
	
	# enable this debug line if problem parsing sql file due to bad characters
	DEBUG "FileLine#${l_FileLineNum} SqlLine#${l_SqlLineNum} : Chars=${cCnt} : ${lStr} "

	# replace first char is slash then end SQL
	if [ "${sChar1}" = "/" ]; then
		 sChar1=";"
		sStr="${sStr} ;"
	else
		sStr="${sStr} ${lStr}"
	fi

	# start new SQL if first char is semi-color or slash OR last char is semi-colon
	if [[ "${sChar1}" == ";" || "${sChar1}" == "/" || "${sChar2}" == ";" ]]; then

		# trim leading whitespaces
		sStr="${sStr#"${sStr%%[![:space:]]*}"}"

		ECHO "${cLINE2}"
		(( sNum=sNum+1 ))
		DEBUG "SQL#${sNum} : ${sStr}"
		# create sql file per statement - use this for execution
		ECHO "${sStr}" > ${TMPSQL}.${sNum}
		DEBUG "SQL#${sNum} file is ${TMPSQL}.${sNum}"

		# NOTES: SQL file already created above. Use that for execution in DB. Do not use converted SQL for execution.

		# convert to upper case. 
		sStr=${sStr^^}
		#DEBUG "Parse SQL to find SQL Type SQL Sub Type"
		ECHO "#SQL ${sNum}"
		ECHO "#SQL ${sStr}"

		if [ "${rc_SPLITSQL_FIND_SQLTYPE}" != "NO" ]; then
			DEBUG "Find SQL Type for ${sStr}"
			f_find_sql_type "${sStr}"
			ECHO "#SQL Type ID # ${l_SqlTypeID}"
			ECHO "#SQL Type Name ${l_SqlType}"

			if [ "${rc_SPLITSQL_PROCESS_SQLTYPE_RULES}" != "NO" ]; then
				DEBUG "Show rules for SQL Type (Rules-Category-2) ${l_SqlTypeUnderscore}"
				vGrepPattern="^[0-9]*:[A-Za-z0-9]*:[Y]:.*:${l_SqlTypeUnderscore}:"
				ShowRulesForPattern
				#ExecRulesForPattern
			fi

			if [ "${rc_SPLITSQL_FIND_SQLOBJECT}" != "NO" ]; then
				DEBUG "Find SQL Object"
				f_find_sql_object
				ECHO "#SQL Obj Name  ${l_SqlObjectName}"
			fi

			if [ "${rc_SPLITSQL_FIND_SQLSUBTYPE}" != "NO" ]; then
				DEBUG "Find SQL Sub Type for ${l_SqlType}"
				f_find_sql_sub_type 
				ECHO "#SQL Sub Type ID ${l_SqlSubTypeID}"
				ECHO "#SQL Sub Type ${l_SqlSubType}"
				ECHO "#SQL Sub Name ${l_SqlSubTypeSearchName}"

				if [ "${rc_SPLITSQL_PROCESS_SQLSUBTYPE_RULES}" != "NO" ]; then
					DEBUG "Show rules for Rule-Name (Based on SQL Sub type)"
					#vGrepPattern="^[0-9]*:${l_SqlSubTypeSearchName}:[Y]:.*:${l_SqlTypeUnderscore}:"
					#ShowRulesForPattern

					DEBUG "Show rules for Rules-Category-3 (SQL Sub Type)"
					#vGrepPattern="^[0-9]*:[A-Za-z0-9]*:[Y]:.*:${l_SqlTypeUnderscore}:${"
					#ShowRulesForPattern
				fi
			fi
		fi

		ECHO "${cLINE2}"
		# start new sql string
		sStr=""
		l_SqlLineNum=0
		l_SqlTypeID=0
		l_SqlType=""
		l_SqlTypeUnderscore=""
		l_SqlSubType=""
		l_SqlSubTypeID=0
		l_SqlObjectName=""
		l_SqlSubTypeSearchName=""
	fi
done < ${TMPSCR} 

ECHO "${cLINE2}"
ECHO "Summary:"
ECHO "Input Script ${sFile}"
ECHO "Number of lines : ${l_FileLineNum}"
ECHO "Number of chars : ${cCnt}"
ECHO "Number of SQLs : ${sNum}"
}
